Install
run: npm install --save react-router-dom
# The Router

- For browser based projects, there are < BrowserRouter > and < HashRouter > components. The <BrowserRouter> should be used when you have a server that will handle dynamic requests (knows how to respond to any possible URI), while the < HashRouter > should be used for static websites (where the server can only respond to requests for files that it knows about).

# History

- Each router creates a history object, which it uses to keep track of the current location 1 and re-render the website whenever that changes. The other components provided by React Router rely on having that history object available through React’s context, so they must be rendered as descendants of a router component.

# Rendering a Router

- Router components only expect to receive a single child element.
- To work within this limitation, it is useful to create an < App > component that renders the rest of your application. Separating your application from the router is also useful for server rendering because you can re-use the < App > on the server while switching the router to a < MemoryRouter >.

[ Note: < MemoryRouter >
A < Router > that keeps the history of your “URL” in memory (does not read or write to the address bar). Useful in tests and non-browser environments ]


# The App

Our application is defined within the < App > component. To simplify things, we will split our application into two parts. The < Header > component will contain links to navigate throughout the website. The < Main > component is where the rest of the content will be rendered.


# Routes

- Main building block of React Router.
- Use to render content based on the location’s pathname, you should use a <Route> element.
- React Router only cares about the pathname of a location.

Path

A < Route > expects a path prop, which is a string that describes the pathname that the route matches — for example, <Route path='/roster'/> should match a pathname that begins with /roster .
When the current location’s pathname is matched by the path, the route will render a React element

Matching paths

React Router uses the path-to-regexp package to determine if a route element’s path prop matches the current location. It compiles the path string into a regular expression, which will be matched against the location’s pathname.

When the route’s path matches, a match object with the following properties will be created:

"url" -> the matched part of the current location’s pathname path the route's path
"isExact" -> path = = = pathname
"params" -> an object containing values from the pathname that were captured by path-to-regexp

# Creating routes

- < Routes > can be created anywhere inside of the router.
- < Switch > component can be usd to group < Routes >. The < Switch > will iterate over its children elements (the routes) and only render the first one that matches the current pathname.



### What does the < Route > render?

- Routes have three props that can be used to define what should be rendered when the route’s path matches.
- Only one should be provided to a <Route> element.

1. component — A React component. When a route with a component prop matches, the route will return a new element whose type is the provided React component (created using React.createElement).

2. render — A function that returns a React element. It will be called when the path matches. This is similar to component, but is useful for inline rendering and passing extra props to the element.

3. children — A function that returns a React element. Unlike the prior two props, this will always be rendered, regardless of whether the route’s path matches the current location.


- Typically, either the component or render prop should be used. The children prop can be useful occasionally, but typically it is preferable to render nothing when the path does not match.
- The element rendered by the < Route > will be passed a number of props. These will be the match object, the current location object 6, and the history object (the one created by our router)

# < Main >

- we will render our < Switch > and <Route>s inside of our < Main > component, which will place the HTML generated by a matched route inside of a <main> DOM node.


Note: The route for the homepage includes an exact prop. This is used to state that that route should only match when the pathname matches the route’s path exactly.

## Nested Routes

- The player profile route /roster/:number is not included in the above < Switch >. Instead, it will be rendered by the < Roster > component, which is rendered whenever the pathname begins with /roster.

-> Within the < Roster > component we will render routes for two paths:

- /roster — This should only be matched when the pathname is exactly /roster, so we should also give that route element the exact prop.
- /roster/:number — This route uses a path param to capture the part of the pathname that comes after /roster.

---

- It can be useful to group routes that share a common prefix in the same component.

e.g:- As an example, < Roster > could render a title that would be displayed for all routes whose path begins with /roster.


## Path Params

- Sometimes there are variables within a pathname that we want to capture.
- The :number part of the path /roster/:number means that the part of the pathname that comes after /roster/ will be captured and stored as match.params.number.
- For example, the pathname /roster/6 will generate a params object: { number: '6' }
- NOTE:- The captured value is a string.

-> The < Player > component can use the props.match.params object to determine which player’s data should be rendered.


## Links

- If we were to create links using anchor elements, clicking on them would cause the whole page to reload.
- React Router provides a < Link > component to prevent that from happening. When clicking a < Link >, the URL will be updated and the rendered content will change without reloading the page.


- < Link >s use the "to" prop to describe the location that they should navigate to. This can either be a string or a location object (containing a combination of pathname, search, hash, and state properties). When it is a string, it will be converted to a location object.

eg:- < Link to={{ pathname: '/roster/7' }}>Player #7</ Link >

NOTES:-

- Locations are objects with properties to describe the different parts of a URL:

  - A basic location object
    { pathname: '/', search: '', hash: '', key: 'abc123' state: {} }

- You can render a pathless < Route >, which will match every location. This can be useful for accessing methods and variables that are stored in the context.
- If you use the children prop, the route will render even when its path does not match the current location.

- There is work being done to add support for relative < Route >s and < Link >s. Relative < Link >s are more complicated than they might initially seem to be because they should be resolved using their parent match object, not the current URL.
- The < Route > and < Switch > components can both take a location prop. This allows them to be matched using a location that is different than the actual location (the current URL).
- They are also passed a staticContext prop, but that is only useful when doing server side rendering.
  refer:- https://blog.pshrmn.com/simple-react-router-v4-tutorial/
